---
phase: 05-progress-rewards
plan: 04
type: execute
wave: 1
depends_on: []
files_modified:
  - assets/audio/correct.mp3
  - assets/audio/incorrect.mp3
  - assets/audio/complete.mp3
  - assets/audio/click.mp3
  - scripts/generate-audio.js
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "SoundManager initializes on first user gesture (avoids autoplay block)"
    - "Sound effects play on user interactions when enabled"
    - "Correct answers play positive 'ding' sound"
    - "Incorrect answers play gentle 'whoops' sound"
  artifacts:
    - path: "assets/audio/correct.mp3"
      provides: "Positive achievement sound (ding/chime)"
      min_size: 1000
    - path: "assets/audio/incorrect.mp3"
      provides: "Gentle negative feedback sound"
      min_size: 1000
    - path: "assets/audio/complete.mp3"
      provides: "Quiz completion celebration jingle"
      min_size: 1000
    - path: "assets/audio/click.mp3"
      provides: "UI interaction click sound"
      min_size: 500
  key_links:
    - from: "src/services/sound.js"
      to: "assets/audio/*.mp3"
      via: "fetch and decode audio buffers"
      pattern: "loadSound\\('\\w+',\\s*'assets/audio/\\w+\\.mp3'\\)"
---

<objective>
Generate missing audio files to enable SoundManager functionality

Purpose: Close UAT gaps by creating the 4 required audio files that SoundManager expects but were never generated
Output: Browser-compatible MP3 files with child-friendly sound design
</objective>

<execution_context>
@C:\Users\Furby\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\Furby\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/05-progress-rewards/05-UAT.md
@src/services/sound.js
@assets/audio/README.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create audio generation script using Node.js and Web Audio principles</name>
  <files>scripts/generate-audio.js</files>
  <action>
Create a Node.js script that generates simple synthesized audio files using tone generation. The script will create child-friendly sounds programmatically without requiring external downloads.

**Implementation approach:**
Use a simple WAV generator library or implement basic WAV synthesis with sine/square waves. Create 4 distinct sounds:

1. **correct.mp3** - Positive achievement (C major chord arpeggio, ascending)
   - Frequencies: 523Hz (C5) -> 659Hz (E5) -> 784Hz (G5)
   - Duration: 0.4s total (0.12s per note)
   - Envelope: Quick attack, gentle decay
   - Volume: Gentle, not jarring

2. **incorrect.mp3** - Gentle feedback (descending tone, non-harsh)
   - Frequencies: 392Hz (G4) -> 330Hz (E4)
   - Duration: 0.3s total (0.15s per note)
   - Envelope: Soft attack, gradual fade
   - Volume: Lower than correct sound

3. **complete.mp3** - Celebration jingle (major scale run)
   - Frequencies: 523Hz -> 587Hz -> 659Hz -> 784Hz (C-D-E-G major)
   - Duration: 0.6s total (0.15s per note)
   - Envelope: Bright attack, sustain
   - Volume: Medium-bright, celebratory

4. **click.mp3** - UI interaction (short pop)
   - Frequency: 1000Hz brief burst with quick envelope
   - Duration: 0.05s
   - Envelope: Instant attack, instant decay
   - Volume: Subtle

**Code structure:**
```javascript
#!/usr/bin/env node

// Simple WAV file generator
// Generates 16-bit PCM WAV files, then converts to MP3 using FFmpeg (if available)
// Falls back to WAV if FFmpeg not installed

const fs = require('fs');
const path = require('path');

class SimpleAudioGenerator {
    constructor(sampleRate = 44100) {
        this.sampleRate = sampleRate;
    }

    // Generate sine wave tone
    generateTone(frequency, duration, volume = 0.3) {
        const samples = Math.floor(this.sampleRate * duration);
        const buffer = new Float32Array(samples);

        for (let i = 0; i < samples; i++) {
            const t = i / this.sampleRate;
            // Apply envelope (fade in/out)
            const envelope = this.envelope(i, samples);
            buffer[i] = Math.sin(2 * Math.PI * frequency * t) * volume * envelope;
        }

        return buffer;
    }

    // Simple envelope (attack-decay-sustain-release)
    envelope(sample, totalSamples) {
        const attackSamples = totalSamples * 0.1;
        const releaseSamples = totalSamples * 0.2;

        if (sample < attackSamples) {
            return sample / attackSamples; // Fade in
        } else if (sample > totalSamples - releaseSamples) {
            return (totalSamples - sample) / releaseSamples; // Fade out
        }
        return 1.0; // Sustain
    }

    // Concatenate multiple tones (for arpeggios)
    concatenateTones(tones) {
        const totalLength = tones.reduce((sum, tone) => sum + tone.length, 0);
        const result = new Float32Array(totalLength);
        let offset = 0;

        for (const tone of tones) {
            result.set(tone, offset);
            offset += tone.length;
        }

        return result;
    }

    // Convert Float32Array to 16-bit PCM
    floatTo16BitPCM(float32Array) {
        const buffer = new Int16Array(float32Array.length);
        for (let i = 0; i < float32Array.length; i++) {
            const s = Math.max(-1, Math.min(1, float32Array[i]));
            buffer[i] = s < 0 ? s * 0x8000 : s * 0x7FFF;
        }
        return buffer;
    }

    // Create WAV file header
    createWavHeader(dataLength) {
        const buffer = new ArrayBuffer(44);
        const view = new DataView(buffer);

        // RIFF header
        this.writeString(view, 0, 'RIFF');
        view.setUint32(4, 36 + dataLength, true);
        this.writeString(view, 8, 'WAVE');

        // fmt chunk
        this.writeString(view, 12, 'fmt ');
        view.setUint32(16, 16, true); // fmt chunk size
        view.setUint16(20, 1, true); // PCM format
        view.setUint16(22, 1, true); // Mono
        view.setUint32(24, this.sampleRate, true);
        view.setUint32(28, this.sampleRate * 2, true); // Byte rate
        view.setUint16(32, 2, true); // Block align
        view.setUint16(34, 16, true); // Bits per sample

        // data chunk
        this.writeString(view, 36, 'data');
        view.setUint32(40, dataLength, true);

        return new Uint8Array(buffer);
    }

    writeString(view, offset, string) {
        for (let i = 0; i < string.length; i++) {
            view.setUint8(offset + i, string.charCodeAt(i));
        }
    }

    // Save as WAV file
    saveWav(filename, float32Array) {
        const pcmData = this.floatTo16BitPCM(float32Array);
        const dataLength = pcmData.length * 2;
        const header = this.createWavHeader(dataLength);

        const wavData = new Uint8Array(header.length + pcmData.length * 2);
        wavData.set(header, 0);
        wavData.set(new Uint8Array(pcmData.buffer), header.length);

        fs.writeFileSync(filename, wavData);
        console.log(`Created: ${filename} (${wavData.length} bytes)`);
    }
}

// Generate sounds
const generator = new SimpleAudioGenerator();
const outputDir = path.join(__dirname, '..', 'assets', 'audio');

// Create output directory if needed
if (!fs.existsSync(outputDir)) {
    fs.mkdirSync(outputDir, { recursive: true });
}

// 1. Correct sound - C major arpeggio ascending
const correctTones = [
    generator.generateTone(523, 0.12, 0.25), // C5
    generator.generateTone(659, 0.12, 0.25), // E5
    generator.generateTone(784, 0.12, 0.25)  // G5
];
const correctSound = generator.concatenateTones(correctTones);
generator.saveWav(path.join(outputDir, 'correct.wav'), correctSound);

// 2. Incorrect sound - Gentle descending
const incorrectTones = [
    generator.generateTone(392, 0.15, 0.2), // G4
    generator.generateTone(330, 0.15, 0.2)  // E4
];
const incorrectSound = generator.concatenateTones(incorrectTones);
generator.saveWav(path.join(outputDir, 'incorrect.wav'), incorrectSound);

// 3. Complete sound - Major scale celebration
const completeTones = [
    generator.generateTone(523, 0.12, 0.3), // C
    generator.generateTone(587, 0.12, 0.3), // D
    generator.generateTone(659, 0.12, 0.3), // E
    generator.generateTone(784, 0.2, 0.35)  // G (longer final note)
];
const completeSound = generator.concatenateTones(completeTones);
generator.saveWav(path.join(outputDir, 'complete.wav'), completeSound);

// 4. Click sound - Short pop
const clickSound = generator.generateTone(1000, 0.05, 0.15);
generator.saveWav(path.join(outputDir, 'click.wav'), clickSound);

console.log('\nâœ“ Generated 4 WAV files');
console.log('\nNote: Browsers support WAV natively.');
console.log('The SoundManager will load these .wav files.');
console.log('Update sound.js to load .wav instead of .mp3');
```

This approach:
- Generates audio programmatically (no external downloads)
- Creates WAV files (widely supported, no encoding needed)
- Uses simple sine wave synthesis
- Child-friendly tone design (gentle, not harsh)
- No external dependencies beyond Node.js built-ins
  </action>
  <verify>
Run script:
```bash
node scripts/generate-audio.js
```

Check output:
```bash
ls -lh assets/audio/*.wav
```

Should show 4 WAV files with sizes 5-30KB each.
  </verify>
  <done>Script exists and generates 4 WAV files with child-friendly synthesized sounds</done>
</task>

<task type="auto">
  <name>Task 2: Update SoundManager to load WAV files instead of MP3</name>
  <files>src/services/sound.js</files>
  <action>
Update the file extension references from .mp3 to .wav in the loadSound calls:

**Change lines 42-45 from:**
```javascript
await Promise.all([
    this.loadSound('correct', 'assets/audio/correct.mp3'),
    this.loadSound('incorrect', 'assets/audio/incorrect.mp3'),
    this.loadSound('complete', 'assets/audio/complete.mp3'),
    this.loadSound('click', 'assets/audio/click.mp3')
]);
```

**To:**
```javascript
await Promise.all([
    this.loadSound('correct', 'assets/audio/correct.wav'),
    this.loadSound('incorrect', 'assets/audio/incorrect.wav'),
    this.loadSound('complete', 'assets/audio/complete.wav'),
    this.loadSound('click', 'assets/audio/click.wav')
]);
```

**Why WAV instead of MP3:**
- Web Audio API decodes both formats equally well
- WAV is uncompressed (simpler to generate without external tools)
- File sizes are acceptable for short sounds (<30KB each)
- No licensing concerns with MP3 encoding
- Browser support is universal for WAV
  </action>
  <verify>
Grep shows .wav extension in loadSound calls:
```bash
grep -n "loadSound.*\.wav" src/services/sound.js
```
  </verify>
  <done>SoundManager loads .wav files, matching the generated audio assets</done>
</task>

<task type="auto">
  <name>Task 3: Generate audio files and verify integration</name>
  <files>assets/audio/correct.wav, assets/audio/incorrect.wav, assets/audio/complete.wav, assets/audio/click.wav</files>
  <action>
Execute the generation script and verify output:

1. Run the audio generator:
```bash
node scripts/generate-audio.js
```

2. Verify all 4 files were created:
```bash
ls -lh assets/audio/*.wav
```

Expected output: 4 files (correct.wav, incorrect.wav, complete.wav, click.wav), each between 5-30KB

3. Test in browser (manual step - open DevTools console):
```javascript
// After clicking anywhere on the page
window.soundManager.play('click');
window.soundManager.play('correct');
window.soundManager.play('incorrect');
window.soundManager.play('complete');
```

Each command should play a distinct sound.

4. Update README.md to reflect that audio files are now generated:
```bash
cat > assets/audio/README.md << 'EOF'
# Audio Assets

Sound effects for "KI & ich" learning app.

## Files

Generated programmatically using `scripts/generate-audio.js`:

- **correct.wav** - Positive achievement sound (C major arpeggio)
- **incorrect.wav** - Gentle feedback tone (descending)
- **complete.wav** - Quiz completion celebration (major scale)
- **click.wav** - UI interaction click (short pop)

## Regenerating

Run: `node scripts/generate-audio.js`

All sounds use simple sine wave synthesis (child-friendly, not harsh).
EOF
```
  </action>
  <verify>
1. `ls assets/audio/*.wav` shows 4 files
2. `file assets/audio/correct.wav` shows "WAVE audio"
3. Browser console test plays sounds without errors
4. README.md updated
  </verify>
  <done>Audio files exist and SoundManager can load and play them successfully</done>
</task>

</tasks>

<verification>
1. scripts/generate-audio.js exists and runs without errors
2. assets/audio/ contains 4 WAV files (correct, incorrect, complete, click)
3. src/services/sound.js references .wav instead of .mp3
4. SoundManager.init() loads all 4 sounds successfully
5. soundManager.play('correct') produces audible sound in browser
6. UAT gaps for Tests 1 and 3 are resolved (audio files exist, SoundManager can initialize)
</verification>

<success_criteria>
- All 4 WAV files exist and are valid audio (5-30KB each)
- SoundManager initializes without errors when user clicks
- play('correct'), play('incorrect'), play('complete'), play('click') all produce sound
- Sounds are child-friendly (gentle tones, not harsh or scary)
- UAT Test 1 ("Sound effects play") passes
- UAT Test 3 ("SoundManager initializes on first user gesture") passes
</success_criteria>

<output>
After completion, create `.planning/phases/05-progress-rewards/05-04-SUMMARY.md`
</output>
