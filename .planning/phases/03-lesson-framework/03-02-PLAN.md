---
phase: 03-lesson-framework
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/components/lesson/lesson-renderer.js
  - src/components/lesson/lesson-screen.js
autonomous: true

must_haves:
  truths:
    - "User can see current screen content"
    - "User can navigate to next/previous screens"
    - "Progress bar shows current position"
    - "Kiki reacts to screen changes with emotions and messages"
  artifacts:
    - path: "src/components/lesson/lesson-renderer.js"
      provides: "Main lesson display and navigation controller"
      exports: ["LessonRenderer", "SCREEN_TYPES"]
    - path: "src/components/lesson/lesson-screen.js"
      provides: "Individual screen content rendering"
      exports: ["renderScreen"]
  key_links:
    - from: "lesson-renderer.js"
      to: "window.kiki"
      via: "triggerKikiAction method"
      pattern: "window\\.kiki\\.(setEmotion|speak)"
    - from: "lesson-renderer.js"
      to: "state"
      via: "savePosition"
      pattern: "state\\.(get|set)"
---

<objective>
Create the LessonRenderer component that displays lesson screens with navigation.

Purpose: Enable users to view and navigate through lesson content with Kiki guidance.
Output: Reusable lesson rendering system that handles all screen types and integrates with Kiki mascot.
</objective>

<execution_context>
@C:\Users\Furby\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\Furby\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-lesson-framework/03-RESEARCH.md

Existing patterns:
- Components are functions returning HTML strings OR classes with render()
- State via StateManager: state.get(key), state.set(key, value)
- Kiki via window.kiki: setEmotion(emotion), speak(text, {duration})
- Event handling: addEventListener with event delegation
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create lesson-screen.js (screen rendering)</name>
  <files>src/components/lesson/lesson-screen.js</files>
  <action>
Create the screen rendering module that generates HTML for different screen types.

Create `src/components/lesson/` directory and `lesson-screen.js`:

1. Export SCREEN_TYPES constant:
```javascript
export const SCREEN_TYPES = {
  INTRO: 'intro',
  EXPLANATION: 'explanation',
  EXAMPLE: 'example',
  INTERACTIVE: 'interactive',
  SUMMARY: 'summary'
};
```

2. Export `renderScreen(screen)` function that:
   - Extracts content fields (heading, text, subtext, bullets, illustration)
   - Creates HTML strings for each content type:
     - heading: `<h2 class="lesson-heading">`
     - text: `<p class="lesson-text">`
     - subtext: `<p class="lesson-subtext">`
     - bullets: `<ul class="lesson-bullets">` with `<li>` items
     - illustration: `<img class="lesson-illustration">` (only if defined)
   - Returns different layouts based on screen.type:
     - intro: illustration, heading, text, subtext (centered)
     - explanation: heading, text, bullets, illustration
     - example: illustration, heading, text, subtext
     - interactive: heading, text, choices buttons
     - summary: heading, bullets, nextAction
   - For interactive screens, render choices as buttons with data attributes

Interactive choices HTML pattern:
```html
<div class="lesson-choices">
  <button class="lesson-choice" data-index="0" data-correct="true">
    Choice text
  </button>
</div>
```

All content wrapped in `<div class="lesson-screen-content lesson-screen-content--{type}">`.
  </action>
  <verify>
File exists at src/components/lesson/lesson-screen.js with:
- SCREEN_TYPES exported
- renderScreen function exported
- Handles all 5 screen types
- Returns HTML strings (no DOM manipulation)
  </verify>
  <done>Screen rendering module with type-specific layouts</done>
</task>

<task type="auto">
  <name>Task 2: Create lesson-renderer.js (navigation controller)</name>
  <files>src/components/lesson/lesson-renderer.js</files>
  <action>
Create the main LessonRenderer class that manages screen display and navigation.

Implementation:

1. Import renderScreen and SCREEN_TYPES from lesson-screen.js
2. Re-export SCREEN_TYPES for external use

3. Create LessonRenderer class:
```javascript
export class LessonRenderer {
  constructor(container, lessonData, state) {
    this.container = container;
    this.lesson = lessonData;
    this.state = state;
    this.currentScreen = 0;
    this.totalScreens = lessonData.screens.length;

    // Bind methods
    this.nextScreen = this.nextScreen.bind(this);
    this.prevScreen = this.prevScreen.bind(this);
  }
```

4. Implement methods:
   - `render()`: Initial render with progress bar, screen container, navigation buttons
   - `getProgress()`: Returns percentage (currentScreen+1)/totalScreens * 100
   - `isLastScreen()`: currentScreen === totalScreens - 1
   - `savePosition()`: state.set(`lesson_${lesson.id}_position`, currentScreen)
   - `loadPosition()`: Get saved position from state, validate bounds
   - `nextScreen()`: If last screen, navigate to #/quiz/{id}, else goToScreen(current+1)
   - `prevScreen()`: If current > 0, goToScreen(current-1)
   - `goToScreen(index)`: Validate bounds, set currentScreen, save position, update UI
   - `updateScreen(direction)`: CSS transition animation, update content
   - `updateProgress()`: Update progress bar fill and text
   - `updateNavButtons()`: Update disabled state, button text ("Weiter" vs "Quiz starten")
   - `triggerKikiAction()`: Call window.kiki.setEmotion and speak based on current screen
   - `attachEventListeners()`: Click handlers for prev/next, keyboard arrows, touch swipe
   - `handleChoiceClick(element)`: Visual feedback, call window.kiki.reactToAnswer

5. render() method HTML structure:
```html
<div class="lesson-renderer">
  <div class="lesson-progress">
    <div class="lesson-progress-bar">
      <div class="lesson-progress-fill" style="width: {progress}%"></div>
    </div>
    <span class="lesson-progress-text">1 / 5</span>
  </div>

  <div class="lesson-screen-container">
    <div class="lesson-screen" data-screen="0">
      {renderScreen(screens[0])}
    </div>
  </div>

  <nav class="lesson-screen-nav">
    <button class="lesson-nav-btn lesson-nav-btn--prev" disabled>Zurueck</button>
    <button class="lesson-nav-btn lesson-nav-btn--next">Weiter</button>
  </nav>
</div>
```

6. Touch swipe implementation:
   - Track touchstart X position
   - On touchend, calculate diff
   - If diff > 50px: swipe left = next, swipe right = prev

7. Keyboard navigation:
   - ArrowRight: nextScreen
   - ArrowLeft: prevScreen

Note: Store keyboard listener reference to remove on cleanup if needed.
  </action>
  <verify>
File exists at src/components/lesson/lesson-renderer.js with:
- LessonRenderer class exported
- SCREEN_TYPES re-exported
- render() method creates full UI
- Navigation works (next/prev/touch/keyboard)
- Kiki integration via triggerKikiAction
- Progress saving via state
  </verify>
  <done>LessonRenderer class with complete navigation and Kiki integration</done>
</task>

</tasks>

<verification>
1. Module imports work: No syntax errors
2. All screen types handled in renderScreen
3. Navigation logic covers all edge cases (first screen, last screen)
4. Kiki methods called correctly (setEmotion, speak, reactToAnswer)
</verification>

<success_criteria>
- LessonRenderer renders progress bar, content, and navigation
- Navigation buttons work (next/prev with disabled states)
- Touch swipe moves between screens
- Keyboard arrows navigate screens
- Kiki emotion and message update on screen change
- Progress position saved to state
- Interactive choices provide visual feedback
</success_criteria>

<output>
After completion, create `.planning/phases/03-lesson-framework/03-02-SUMMARY.md`
</output>
